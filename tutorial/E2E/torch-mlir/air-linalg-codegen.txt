Args: air-opt input.mlir --air-linalg-codegen -debug -o input1.mlir 
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TypedAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DistinctAttr)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ResourceBlobManagerDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeDialectInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineBinaryOpExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineConstantExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineDimExprStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::AffineMapStorage)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::IntegerSetStorage)
Load new dialect in Context builtin
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CastOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableTypeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneRegion<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroSuccessors<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoRegionArguments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NoTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlock<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OpInvariants<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BytecodeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AffineScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsIsolatedFromAbove<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SymbolTable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpAsmOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionKindInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasOnlyGraphRegion<Empty>)
Load new dialect in Context memref
Load new dialect in Context arith
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithFastMathInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferIntRangeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithIntegerOverflowFlagsInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithRoundingModeInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SelectLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectInlinerInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConvertToLLVMPatternInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferDeallocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferizableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ValueBoundsOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::BufferViewFlowOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CopyOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableMemOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableAccessorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableAllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableAllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedDimOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ReifyRankedShapedTypeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OffsetSizeAndStrideOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::bufferization::AllocationOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RuntimeVerifiableOpInterface)
Load new dialect in Context affine
Load new dialect in Context ub
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ub::PoisonAttrInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineDmaStartOp)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineMapAccessInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineDmaWaitOp)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineReadOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::AffineWriteOpInterface)
Load new dialect in Context cf
ImplicitTypeIDRegistry::lookupOrInsert(mlir::BranchOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ZeroRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::memref::detail::GlobalOpGenericAdaptorBase::Properties)
Load new dialect in Context func
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::mesh::ShardingInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AutomaticAllocationScope<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallableOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::FunctionOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneResult<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ConstantLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ConditionallySpeculatable::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffectOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferIntRangeInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::InferTypeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::detail::ConstantOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::MemRefType>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicOperands<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AttrSizedOperandSegments<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PromotableAllocationOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestructurableAllocationOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::memref::detail::AllocaOpGenericAdaptorBase::Properties)
Load new dialect in Context linalg
Load new dialect in Context math
Load new dialect in Context tensor
Load new dialect in Context complex
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestinationStyleOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::transform::FindPayloadReplacementOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubsetOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubsetInsertionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SubsetExtractionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TilingInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::AggregatedOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::LinalgOp)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::ContractionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::ConvolutionOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::FillOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::PartialReductionOpInterface)
Load new dialect in Context scf
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ParallelCombiningOpInterface)
Ignoring repeated interface registration
Ignoring repeated interface registration
Ignoring repeated interface registration
Load new dialect in Context index
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicResults<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::linalg::YieldOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasRecursiveMemoryEffects<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DestinationStyleOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::LinalgOp::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ReifyRankedShapedTypeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::FillOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::linalg::ContractionOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::detail::MulFOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::detail::AddFOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::NOperands<2>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::CopyOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsElementType<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsShape<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::MemRefsNormalizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchTerminatorOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::ReturnLike<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsTerminator<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutSpecInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithFastMathInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::IsCommutative<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SameOperandsAndResultType<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::VectorUnrollOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Elementwise<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Scalarizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Vectorizable<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::Tensorizable<Empty>)
Load new dialect in Context air
ImplicitTypeIDRegistry::lookupOrInsert(xilinx::air::AsyncTokenType)
ImplicitTypeIDRegistry::lookupOrInsert(xilinx::air::AsyncOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(xilinx::air::MemcpyInterface)
ImplicitTypeIDRegistry::lookupOrInsert(xilinx::air::ChannelInterface)
ImplicitTypeIDRegistry::lookupOrInsert(xilinx::air::HierarchyInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::OpToOpPassAdaptor)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DialectFoldInterface)

//===-------------------------------------------===//
Processing operation : 'func.return'(0x573a529df9e0) {
  "func.return"() : () -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'func.return -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x573a52a3c7f0) {
  "linalg.yield"(%1) : (f32) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'linalg.yield -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x573a52a3f380) {
  %1 = "arith.addf"(%arg5, %0) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.addf -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a52a3c850) {
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Read)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SideEffects::DefaultResource)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Write)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Allocate)

  * Pattern (anonymous namespace)::TileLinalgOpPattern : 'linalg.matmul -> ()' {
Trying to match "(anonymous namespace)::TileLinalgOpPattern"
    ** Insert  : 'arith.constant'(0x573a52a41eb0)
    ** Insert  : 'arith.constant'(0x573a52a41f20)
    ** Insert  : 'arith.constant'(0x573a52a41f90)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::detail::AffineApplyOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<Empty>)
    ** Insert  : 'arith.constant'(0x573a52a44d70)
    ** Insert  : 'arith.constant'(0x573a52a44de0)
    ** Insert  : 'arith.constant'(0x573a52a44e50)
    ** Insert  : 'arith.constant'(0x573a52a44ec0)
    ** Insert  : 'arith.constant'(0x573a52a44f30)
    ** Insert  : 'arith.constant'(0x573a52a44fa0)
    ** Insert  : 'arith.constant'(0x573a52a45010)
    ** Insert  : 'arith.constant'(0x573a52a45080)
    ** Insert  : 'arith.constant'(0x573a52a450f0)
    ** Insert  : 'scf.for'(0x573a529ebb80)
makeTiledShapes: for loop#0
computeTileOffsets: <block argument> of type 'index' at index: 0
makeTiledShapes: for loop#1
computeTileOffsets: <block argument> of type 'index' at index: 1
makeTiledShapes: for loop#2
computeTileOffsets: <block argument> of type 'index' at index: 0
computeTileSizes: 31 : index
computeTileSizes: 31 : index
computeTileSizes: 31 : index
makeTiledShapes: for operand <block argument> of type 'memref<2x2xf32>' at index: 0: tiled: figure out subshape...
computeSliceParameters: for dim#0: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2) -> (d0)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<3>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::YieldOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::LoopLikeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::RegionBranchOpInterface::Trait<Empty>)
computeSliceParameters: raw size: 32 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: shapeSize=2, size: 32 : index: make sure in bound with affine.min
ImplicitTypeIDRegistry::lookupOrInsert(mlir::affine::detail::AffineMinOpGenericAdaptorBase::Properties)
    ** Insert  : 'affine.min'(0x573a52a46cf0)
makeTiledShape: new size: block with no terminator, has %0 = "affine.min"(<<UNKNOWN SSA VALUE>>) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%0 = "affine.min"(<<UNKNOWN SSA VALUE>>) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
computeSliceParameters: for dim#1: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2) -> (d2)
computeSliceParameters: raw size: 32 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: shapeSize=2, size: 32 : index: make sure in bound with affine.min
    ** Insert  : 'affine.min'(0x573a52a49790)
makeTiledShape: new size: block with no terminator, has %1 = "affine.min"(%arg0) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%1 = "affine.min"(%arg0) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
makeTiledShapes: for operand <block argument> of type 'memref<2x2xf32>' at index: 1: tiled: figure out subshape...
computeSliceParameters: for dim#0: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2) -> (d2)
computeSliceParameters: raw size: 32 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: shapeSize=2, size: 32 : index: make sure in bound with affine.min
    ** Insert  : 'affine.min'(0x573a52a49920)
makeTiledShape: new size: block with no terminator, has %2 = "affine.min"(%arg0) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%2 = "affine.min"(%arg0) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
computeSliceParameters: for dim#1: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2) -> (d1)
computeSliceParameters: raw size: 32 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 1
makeTiledShape: shapeSize=2, size: 32 : index: make sure in bound with affine.min
    ** Insert  : 'affine.min'(0x573a52a499b0)
makeTiledShape: new size: block with no terminator, has %3 = "affine.min"(<<UNKNOWN SSA VALUE>>) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%3 = "affine.min"(<<UNKNOWN SSA VALUE>>) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
makeTiledShapes: for operand <block argument> of type 'memref<2x2xf32>' at index: 2: tiled: figure out subshape...
computeSliceParameters: for dim#0: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2) -> (d0)
computeSliceParameters: raw size: 32 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 0
makeTiledShape: shapeSize=2, size: 32 : index: make sure in bound with affine.min
    ** Insert  : 'affine.min'(0x573a52a49a40)
makeTiledShape: new size: block with no terminator, has %4 = "affine.min"(<<UNKNOWN SSA VALUE>>) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%4 = "affine.min"(<<UNKNOWN SSA VALUE>>) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
computeSliceParameters: for dim#1: tiled: figure out subsize...
computeSliceParameters: submap: (d0, d1, d2) -> (d1)
computeSliceParameters: raw size: 32 : index
computeSliceParameters: new offset: <block argument> of type 'index' at index: 1
makeTiledShape: shapeSize=2, size: 32 : index: make sure in bound with affine.min
    ** Insert  : 'affine.min'(0x573a52a49ad0)
makeTiledShape: new size: block with no terminator, has %5 = "affine.min"(<<UNKNOWN SSA VALUE>>) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
mlir-asm-printer: 'scf.for' failed to verify and will be printed in generic form
%5 = "affine.min"(<<UNKNOWN SSA VALUE>>) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
ImplicitTypeIDRegistry::lookupOrInsert(mlir::memref::detail::SubViewOpGenericAdaptorBase::Properties)
    ** Insert  : 'memref.subview'(0x573a52a4c2c0)
    ** Insert  : 'memref.subview'(0x573a52a4a890)
    ** Insert  : 'memref.subview'(0x573a52a4a9c0)
    ** Insert  : 'arith.mulf'(0x573a52a4b370)
    ** Insert  : 'arith.addf'(0x573a52a4b7f0)
    ** Insert  : 'linalg.yield'(0x573a529df810)
    ** Insert  : 'linalg.matmul'(0x573a529e9520)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::scf::ExecuteRegionOp, mlir::scf::ForOp, mlir::scf::IfOp, mlir::scf::IndexSwitchOp, mlir::scf::WhileOp>::Impl<Empty>)
    ** Insert  : 'scf.yield'(0x573a529d0a40)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::VariadicRegions<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParent<mlir::scf::ParallelOp>::Impl<Empty>)
    ** Insert  : 'scf.reduce'(0x573a529d0870)
    ** Insert  : 'scf.parallel'(0x573a52a4c450)
    ** Erase   : 'linalg.yield'(0x573a52a3c7f0)
    ** Erase   : 'arith.addf'(0x573a52a3f380)
    ** Erase   : 'arith.mulf'(0x573a52a3f310)
    ** Erase   : 'linalg.matmul'(0x573a52a3c850)
"(anonymous namespace)::TileLinalgOpPattern" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::SingleBlockImplicitTerminator<mlir::scf::ReduceOp>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::HasParallelRegion<Empty>)
func.func @call_mmult(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>) {
  %c32 = arith.constant 32 : index
  %c32_0 = arith.constant 32 : index
  %c32_1 = arith.constant 32 : index
  %c0 = arith.constant 0 : index
  %c2 = arith.constant 2 : index
  %c32_2 = arith.constant 32 : index
  %c0_3 = arith.constant 0 : index
  %c2_4 = arith.constant 2 : index
  %c32_5 = arith.constant 32 : index
  %c0_6 = arith.constant 0 : index
  %c2_7 = arith.constant 2 : index
  %c32_8 = arith.constant 32 : index
  scf.parallel (%arg3, %arg4) = (%c0, %c0_3) to (%c2, %c2_4) step (%c32_2, %c32_5) {
    scf.for %arg5 = %c0_6 to %c2_7 step %c32_8 {
      %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4)
      %4 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %5 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4)
      %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_9 = memref.subview %arg1[%arg5, %arg4] [%2, %3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_10 = memref.subview %arg2[%arg3, %arg4] [%4, %5] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      linalg.matmul {__internal_linalg_transform__ = "L1"} ins(%subview, %subview_9 : memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[2, 1], offset: ?>>) outs(%subview_10 : memref<?x?xf32, strided<[2, 1], offset: ?>>)
    }
    scf.reduce 
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.parallel'(0x573a52a4c450) {

  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'scf.parallel -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a450f0) {
  %11 = "arith.constant"() <{value = 32 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a45080) {
  %10 = "arith.constant"() <{value = 2 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a45010) {
  %9 = "arith.constant"() <{value = 0 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44fa0) {
  %8 = "arith.constant"() <{value = 32 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44f30) {
  %7 = "arith.constant"() <{value = 2 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44ec0) {
  %6 = "arith.constant"() <{value = 0 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44e50) {
  %5 = "arith.constant"() <{value = 32 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44de0) {
  %4 = "arith.constant"() <{value = 2 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44d70) {
  %3 = "arith.constant"() <{value = 0 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a41f90) {
  %2 = "arith.constant"() <{value = 32 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a41f90)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a41f20) {
  %1 = "arith.constant"() <{value = 32 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a41f20)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a41eb0) {
  %0 = "arith.constant"() <{value = 32 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a41eb0)
} -> success : operation is trivially dead
//===-------------------------------------------===//
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ViewLikeOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OffsetSizeAndStrideOpInterface::Trait<Empty>)
** Replace : 'arith.constant'(0x573a52a44ec0)
** Modified: 'scf.parallel'(0x573a52a4c450)
** Erase   : 'arith.constant'(0x573a52a44ec0)
** Replace : 'arith.constant'(0x573a52a44f30)
** Modified: 'scf.parallel'(0x573a52a4c450)
** Erase   : 'arith.constant'(0x573a52a44f30)
** Replace : 'arith.constant'(0x573a52a44fa0)
** Modified: 'scf.parallel'(0x573a52a4c450)
** Erase   : 'arith.constant'(0x573a52a44fa0)
** Replace : 'arith.constant'(0x573a52a45010)
** Modified: 'scf.for'(0x573a529ebb80)
** Erase   : 'arith.constant'(0x573a52a45010)
** Replace : 'arith.constant'(0x573a52a45080)
** Modified: 'scf.for'(0x573a529ebb80)
** Erase   : 'arith.constant'(0x573a52a45080)
** Replace : 'arith.constant'(0x573a52a450f0)
** Modified: 'scf.for'(0x573a529ebb80)
** Erase   : 'arith.constant'(0x573a52a450f0)

//===-------------------------------------------===//
Processing operation : 'func.return'(0x573a529df9e0) {
  "func.return"() : () -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'func.return -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.reduce'(0x573a529d0870) {
  "scf.reduce"() : () -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'scf.reduce -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x573a529d0a40) {
  "scf.yield"() : () -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'scf.yield -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x573a529df810) {
  "linalg.yield"(%13) : (f32) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'linalg.yield -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x573a52a4b7f0) {
  %13 = "arith.addf"(%arg8, %12) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.addf -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a529e9520) {

  * Pattern (anonymous namespace)::TileLinalgOpPattern : 'linalg.matmul -> ()' {
Trying to match "(anonymous namespace)::TileLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: ""
"(anonymous namespace)::TileLinalgOpPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'linalg.matmul -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
ImplicitTypeIDRegistry::lookupOrInsert(mlir::DataLayoutOpInterface)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TargetSystemSpecInterface)
    ** Insert  : 'arith.constant'(0x573a52a44fa0)
    ** Insert  : 'arith.constant'(0x573a52a44f30)
Extract tightest: ImplicitTypeIDRegistry::lookupOrInsert(mlir::CallOpInterface::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::SymbolUserOpInterface::Trait<Empty>)
%0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
Inserting anonymous constraint set column 0
Inserting constraint set column 1 for: %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3) (dim: -1, owner: affine.min)
Push to worklist: %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3) (dim: -1)
Processing value bounds worklist...
Query value bounds for: %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3) (owner: affine.min)
Inserting constraint set column 2 for: <block argument> of type 'index' at index: 0 (dim: -1, owner: scf.parallel)
Push to worklist: <block argument> of type 'index' at index: 0 (dim: -1)
Getting pos for: %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3) (dim: -1, owner: affine.min)
Getting pos for: <block argument> of type 'index' at index: 0 (dim: -1, owner: scf.parallel)
Getting pos for: %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3) (dim: -1, owner: affine.min)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

Stop condition met for: <block argument> of type 'index' at index: 0 (dim: None)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

    ** Insert  : 'arith.constant'(0x573a52a54060)
Extracted tightest: %c32_3 = arith.constant 32 : index
    ** Insert  : 'arith.constant'(0x573a52a41f20)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ShapedDimOpInterface::Trait<Empty>)
Extract tightest: %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
Inserting anonymous constraint set column 0
Inserting constraint set column 1 for: %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5) (dim: -1, owner: affine.min)
Push to worklist: %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5) (dim: -1)
Processing value bounds worklist...
Query value bounds for: %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5) (owner: affine.min)
Inserting constraint set column 2 for: <block argument> of type 'index' at index: 0 (dim: -1, owner: scf.for)
Push to worklist: <block argument> of type 'index' at index: 0 (dim: -1)
Getting pos for: %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5) (dim: -1, owner: affine.min)
Getting pos for: <block argument> of type 'index' at index: 0 (dim: -1, owner: scf.for)
Getting pos for: %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5) (dim: -1, owner: affine.min)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

Stop condition met for: <block argument> of type 'index' at index: 0 (dim: None)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

    ** Insert  : 'arith.constant'(0x573a52a41f90)
Extracted tightest: %c32_5 = arith.constant 32 : index
    ** Insert  : 'arith.constant'(0x573a52a3f380)
    ** Insert  : 'arith.constant'(0x573a52a536b0)
    ** Insert  : 'arith.constant'(0x573a52a53720)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::detail::MulIOpGenericAdaptorBase::Properties)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::arith::ArithIntegerOverflowFlagsInterface::Trait<Empty>)
    ** Insert  : 'arith.constant'(0x573a52a53800)
    ** Insert  : 'arith.constant'(0x573a52a53870)
    ** Insert  : 'memref.alloc'(0x573a52a4fd40)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>)
    ** Insert  : 'memref.view'(0x573a52a3c860)
    ** Insert  : 'memref.subview'(0x573a529d8d70)
    ** Insert  : 'arith.constant'(0x573a52a51cb0)
    ** Insert  : 'arith.constant'(0x573a52a51d20)
Extract tightest: %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
Inserting anonymous constraint set column 0
Inserting constraint set column 1 for: %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5) (dim: -1, owner: affine.min)
Push to worklist: %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5) (dim: -1)
Processing value bounds worklist...
Query value bounds for: %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5) (owner: affine.min)
Inserting constraint set column 2 for: <block argument> of type 'index' at index: 0 (dim: -1, owner: scf.for)
Push to worklist: <block argument> of type 'index' at index: 0 (dim: -1)
Getting pos for: %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5) (dim: -1, owner: affine.min)
Getting pos for: <block argument> of type 'index' at index: 0 (dim: -1, owner: scf.for)
Getting pos for: %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5) (dim: -1, owner: affine.min)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

Stop condition met for: <block argument> of type 'index' at index: 0 (dim: None)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

    ** Insert  : 'arith.constant'(0x573a52a51d90)
Extracted tightest: %c32_13 = arith.constant 32 : index
    ** Insert  : 'arith.constant'(0x573a52a51e70)
Extract tightest: %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4)
Inserting anonymous constraint set column 0
Inserting constraint set column 1 for: %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4) (dim: -1, owner: affine.min)
Push to worklist: %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4) (dim: -1)
Processing value bounds worklist...
Query value bounds for: %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4) (owner: affine.min)
Inserting constraint set column 2 for: <block argument> of type 'index' at index: 1 (dim: -1, owner: scf.parallel)
Push to worklist: <block argument> of type 'index' at index: 1 (dim: -1)
Getting pos for: %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4) (dim: -1, owner: affine.min)
Getting pos for: <block argument> of type 'index' at index: 1 (dim: -1, owner: scf.parallel)
Getting pos for: %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4) (dim: -1, owner: affine.min)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

Stop condition met for: <block argument> of type 'index' at index: 1 (dim: None)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

    ** Insert  : 'arith.constant'(0x573a52a53c40)
Extracted tightest: %c32_15 = arith.constant 32 : index
    ** Insert  : 'arith.constant'(0x573a52a52000)
    ** Insert  : 'arith.constant'(0x573a52a52070)
    ** Insert  : 'arith.constant'(0x573a52a522e0)
    ** Insert  : 'arith.constant'(0x573a52a52350)
    ** Insert  : 'arith.constant'(0x573a52a523c0)
    ** Insert  : 'memref.alloc'(0x573a52a4fba0)
    ** Insert  : 'memref.view'(0x573a529dfa50)
    ** Insert  : 'memref.subview'(0x573a529df880)
    ** Insert  : 'arith.constant'(0x573a52a52670)
    ** Insert  : 'arith.constant'(0x573a52a526e0)
Extract tightest: %4 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
Inserting anonymous constraint set column 0
Inserting constraint set column 1 for: %4 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3) (dim: -1, owner: affine.min)
Push to worklist: %4 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3) (dim: -1)
Processing value bounds worklist...
Query value bounds for: %4 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3) (owner: affine.min)
Inserting constraint set column 2 for: <block argument> of type 'index' at index: 0 (dim: -1, owner: scf.parallel)
Push to worklist: <block argument> of type 'index' at index: 0 (dim: -1)
Getting pos for: %4 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3) (dim: -1, owner: affine.min)
Getting pos for: <block argument> of type 'index' at index: 0 (dim: -1, owner: scf.parallel)
Getting pos for: %4 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3) (dim: -1, owner: affine.min)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

Stop condition met for: <block argument> of type 'index' at index: 0 (dim: None)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

    ** Insert  : 'arith.constant'(0x573a52a51ee0)
Extracted tightest: %c32_26 = arith.constant 32 : index
    ** Insert  : 'arith.constant'(0x573a52a51f50)
Extract tightest: %5 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4)
Inserting anonymous constraint set column 0
Inserting constraint set column 1 for: %5 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4) (dim: -1, owner: affine.min)
Push to worklist: %5 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4) (dim: -1)
Processing value bounds worklist...
Query value bounds for: %5 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4) (owner: affine.min)
Inserting constraint set column 2 for: <block argument> of type 'index' at index: 1 (dim: -1, owner: scf.parallel)
Push to worklist: <block argument> of type 'index' at index: 1 (dim: -1)
Getting pos for: %5 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4) (dim: -1, owner: affine.min)
Getting pos for: <block argument> of type 'index' at index: 1 (dim: -1, owner: scf.parallel)
Getting pos for: %5 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4) (dim: -1, owner: affine.min)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

Stop condition met for: <block argument> of type 'index' at index: 1 (dim: None)
FM input (eliminate pos 1):
Domain: 0, Range: 1, Symbols: 1, Locals: 0
2 constraints
 -1  -1   2  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
1 constraints
 -1   32 >= 0

    ** Insert  : 'arith.constant'(0x573a52a56cd0)
Extracted tightest: %c32_28 = arith.constant 32 : index
    ** Insert  : 'arith.constant'(0x573a52a56d40)
    ** Insert  : 'arith.constant'(0x573a52a52750)
    ** Insert  : 'arith.constant'(0x573a52a3e5b0)
    ** Insert  : 'arith.constant'(0x573a52a3e620)
    ** Insert  : 'arith.constant'(0x573a52a3e690)
    ** Insert  : 'memref.alloc'(0x573a52a4c9b0)
    ** Insert  : 'memref.view'(0x573a529d0ab0)
    ** Insert  : 'memref.subview'(0x573a529d08e0)
    ** Insert  : 'memref.copy'(0x573a52a3e6f0)
    ** Insert  : 'memref.copy'(0x573a52a3e790)
    ** Insert  : 'memref.copy'(0x573a52a3e830)
    ** Insert  : 'memref.copy'(0x573a52a3e8d0)
    ** Insert  : 'memref.dealloc'(0x573a52a37c40)
    ** Insert  : 'memref.dealloc'(0x573a52a45810)
    ** Insert  : 'memref.dealloc'(0x573a52a4f0b0)
    ** Modified: 'linalg.matmul'(0x573a529e9520)
"(anonymous namespace)::PromoteLinalgOpPattern" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
func.func @call_mmult(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>) {
  %c0 = arith.constant 0 : index
  %c2 = arith.constant 2 : index
  %c32 = arith.constant 32 : index
  scf.parallel (%arg3, %arg4) = (%c0, %c0) to (%c2, %c2) step (%c32, %c32) {
    scf.for %arg5 = %c0 to %c2 step %c32 {
      %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4)
      %4 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %5 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4)
      %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_0 = memref.subview %arg1[%arg5, %arg4] [%2, %3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_1 = memref.subview %arg2[%arg3, %arg4] [%4, %5] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %c1 = arith.constant 1 : index
      %c1_2 = arith.constant 1 : index
      %c32_3 = arith.constant 32 : index
      %c0_4 = arith.constant 0 : index
      %c32_5 = arith.constant 32 : index
      %c1_6 = arith.constant 1 : index
      %c0_7 = arith.constant 0 : index
      %c1_8 = arith.constant 1 : index
      %c32_9 = arith.constant 32 : index
      %c1024 = arith.constant 1024 : index
      %alloc = memref.alloc() : memref<4096xi8>
      %view = memref.view %alloc[%c0_7][%c32_3, %c32_5] : memref<4096xi8> to memref<?x?xf32>
      %subview_10 = memref.subview %view[0, 0] [%0, %1] [1, 1] : memref<?x?xf32> to memref<?x?xf32, strided<[?, 1]>>
      %c1_11 = arith.constant 1 : index
      %c1_12 = arith.constant 1 : index
      %c32_13 = arith.constant 32 : index
      %c0_14 = arith.constant 0 : index
      %c32_15 = arith.constant 32 : index
      %c1_16 = arith.constant 1 : index
      %c0_17 = arith.constant 0 : index
      %c1_18 = arith.constant 1 : index
      %c32_19 = arith.constant 32 : index
      %c1024_20 = arith.constant 1024 : index
      %alloc_21 = memref.alloc() : memref<4096xi8>
      %view_22 = memref.view %alloc_21[%c0_17][%c32_13, %c32_15] : memref<4096xi8> to memref<?x?xf32>
      %subview_23 = memref.subview %view_22[0, 0] [%2, %3] [1, 1] : memref<?x?xf32> to memref<?x?xf32, strided<[?, 1]>>
      %c1_24 = arith.constant 1 : index
      %c1_25 = arith.constant 1 : index
      %c32_26 = arith.constant 32 : index
      %c0_27 = arith.constant 0 : index
      %c32_28 = arith.constant 32 : index
      %c1_29 = arith.constant 1 : index
      %c0_30 = arith.constant 0 : index
      %c1_31 = arith.constant 1 : index
      %c32_32 = arith.constant 32 : index
      %c1024_33 = arith.constant 1024 : index
      %alloc_34 = memref.alloc() : memref<4096xi8>
      %view_35 = memref.view %alloc_34[%c0_30][%c32_26, %c32_28] : memref<4096xi8> to memref<?x?xf32>
      %subview_36 = memref.subview %view_35[0, 0] [%4, %5] [1, 1] : memref<?x?xf32> to memref<?x?xf32, strided<[?, 1]>>
      memref.copy %subview, %subview_10 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, strided<[?, 1]>>
      memref.copy %subview_0, %subview_23 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, strided<[?, 1]>>
      memref.copy %subview_1, %subview_36 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, strided<[?, 1]>>
      linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%subview_10, %subview_23 : memref<?x?xf32, strided<[?, 1]>>, memref<?x?xf32, strided<[?, 1]>>) outs(%subview_36 : memref<?x?xf32, strided<[?, 1]>>)
      memref.copy %subview_36, %subview_1 : memref<?x?xf32, strided<[?, 1]>> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      memref.dealloc %alloc : memref<4096xi8>
      memref.dealloc %alloc_21 : memref<4096xi8>
      memref.dealloc %alloc_34 : memref<4096xi8>
    }
    scf.reduce 
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a529e9520) {

  * Pattern (anonymous namespace)::TileLinalgOpPattern : 'linalg.matmul -> ()' {
Trying to match "(anonymous namespace)::TileLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: ""
"(anonymous namespace)::TileLinalgOpPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'linalg.matmul -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a4f0b0) {
  "memref.dealloc"(%48) : (memref<4096xi8>) -> ()

ImplicitTypeIDRegistry::lookupOrInsert(mlir::OpTrait::OneOperand<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemoryEffects::Free)

  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.dealloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a45810) {
  "memref.dealloc"(%35) : (memref<4096xi8>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.dealloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a37c40) {
  "memref.dealloc"(%22) : (memref<4096xi8>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.dealloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e8d0) {
  "memref.copy"(%50, %11) : (memref<?x?xf32, strided<[?, 1]>>, memref<?x?xf32, strided<[2, 1], offset: ?>>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.copy -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e830) {
  "memref.copy"(%11, %50) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.copy -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e790) {
  "memref.copy"(%10, %37) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.copy -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e6f0) {
  "memref.copy"(%9, %24) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.copy -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a529d08e0) {
  %50 = "memref.subview"(%49, %7, %8) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.view'(0x573a529d0ab0) {
  %49 = "memref.view"(%48, %44, %40, %42) : (memref<4096xi8>, index, index, index) -> memref<?x?xf32>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.view -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a4c9b0) {
  %48 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a3e690) {
  %47 = "arith.constant"() <{value = 1024 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a3e690)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a3e620) {
  %46 = "arith.constant"() <{value = 32 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a3e620)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a3e5b0) {
  %45 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a3e5b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a52750) {
  %44 = "arith.constant"() <{value = 0 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a56d40) {
  %43 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a56d40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a56cd0) {
  %42 = "arith.constant"() <{value = 32 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a51f50) {
  %41 = "arith.constant"() <{value = 0 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a51f50)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a51ee0) {
  %40 = "arith.constant"() <{value = 32 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a526e0) {
  %39 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a526e0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a52670) {
  %38 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a52670)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a529df880) {
  %37 = "memref.subview"(%36, %5, %6) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.view'(0x573a529dfa50) {
  %36 = "memref.view"(%35, %31, %27, %29) : (memref<4096xi8>, index, index, index) -> memref<?x?xf32>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.view -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a4fba0) {
  %35 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a523c0) {
  %34 = "arith.constant"() <{value = 1024 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a523c0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a52350) {
  %33 = "arith.constant"() <{value = 32 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a52350)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a522e0) {
  %32 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a522e0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a52070) {
  %31 = "arith.constant"() <{value = 0 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a52000) {
  %30 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a52000)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a53c40) {
  %29 = "arith.constant"() <{value = 32 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a51e70) {
  %28 = "arith.constant"() <{value = 0 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a51e70)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a51d90) {
  %27 = "arith.constant"() <{value = 32 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a51d20) {
  %26 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a51d20)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a51cb0) {
  %25 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a51cb0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a529d8d70) {
  %24 = "memref.subview"(%23, %3, %4) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.view'(0x573a52a3c860) {
  %23 = "memref.view"(%22, %18, %14, %16) : (memref<4096xi8>, index, index, index) -> memref<?x?xf32>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.view -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a4fd40) {
  %22 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a53870) {
  %21 = "arith.constant"() <{value = 1024 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a53870)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a53800) {
  %20 = "arith.constant"() <{value = 32 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a53800)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a53720) {
  %19 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a53720)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a536b0) {
  %18 = "arith.constant"() <{value = 0 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a3f380) {
  %17 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a3f380)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a41f90) {
  %16 = "arith.constant"() <{value = 32 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a41f20) {
  %15 = "arith.constant"() <{value = 0 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a41f20)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a54060) {
  %14 = "arith.constant"() <{value = 32 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44f30) {
  %13 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a44f30)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44fa0) {
  %12 = "arith.constant"() <{value = 1 : index}> : () -> index

  ** Erase   : 'arith.constant'(0x573a52a44fa0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x573a52a4b370) {
  %30 = "arith.mulf"(%arg6, %arg7) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.mulf -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a9c0) {
  %11 = "memref.subview"(%arg2, %arg3, %arg4, %7, %8) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a890) {
  %10 = "memref.subview"(%arg1, %arg5, %arg4, %5, %6) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4c2c0) {
  %9 = "memref.subview"(%arg0, %arg3, %arg5, %3, %4) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49ad0) {
  %8 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49a40) {
  %7 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a499b0) {
  %6 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49920) {
  %5 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49790) {
  %4 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a46cf0) {
  %3 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x573a529ebb80) {

  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.parallel'(0x573a52a4c450) {

  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'scf.parallel -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44e50) {
  %2 = "arith.constant"() <{value = 32 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44de0) {
  %1 = "arith.constant"() <{value = 2 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44d70) {
  %0 = "arith.constant"() <{value = 0 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//
** Replace : 'arith.constant'(0x573a52a54060)
** Modified: 'memref.view'(0x573a52a3c860)
** Erase   : 'arith.constant'(0x573a52a54060)
** Replace : 'arith.constant'(0x573a52a41f90)
** Modified: 'memref.view'(0x573a52a3c860)
** Erase   : 'arith.constant'(0x573a52a41f90)
** Replace : 'arith.constant'(0x573a52a536b0)
** Modified: 'memref.view'(0x573a52a3c860)
** Erase   : 'arith.constant'(0x573a52a536b0)
** Replace : 'arith.constant'(0x573a52a51d90)
** Modified: 'memref.view'(0x573a529dfa50)
** Erase   : 'arith.constant'(0x573a52a51d90)
** Replace : 'arith.constant'(0x573a52a53c40)
** Modified: 'memref.view'(0x573a529dfa50)
** Erase   : 'arith.constant'(0x573a52a53c40)
** Replace : 'arith.constant'(0x573a52a52070)
** Modified: 'memref.view'(0x573a529dfa50)
** Erase   : 'arith.constant'(0x573a52a52070)
** Replace : 'arith.constant'(0x573a52a51ee0)
** Modified: 'memref.view'(0x573a529d0ab0)
** Erase   : 'arith.constant'(0x573a52a51ee0)
** Replace : 'arith.constant'(0x573a52a56cd0)
** Modified: 'memref.view'(0x573a529d0ab0)
** Erase   : 'arith.constant'(0x573a52a56cd0)
** Replace : 'arith.constant'(0x573a52a52750)
** Modified: 'memref.view'(0x573a529d0ab0)
** Erase   : 'arith.constant'(0x573a52a52750)

//===-------------------------------------------===//
Processing operation : 'func.return'(0x573a529df9e0) {
  "func.return"() : () -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'func.return -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.reduce'(0x573a529d0870) {
  "scf.reduce"() : () -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'scf.reduce -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x573a529d0a40) {
  "scf.yield"() : () -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'scf.yield -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a4f0b0) {
  "memref.dealloc"(%18) : (memref<4096xi8>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.dealloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a45810) {
  "memref.dealloc"(%15) : (memref<4096xi8>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.dealloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a37c40) {
  "memref.dealloc"(%12) : (memref<4096xi8>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.dealloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e8d0) {
  "memref.copy"(%20, %11) : (memref<?x?xf32, strided<[?, 1]>>, memref<?x?xf32, strided<[2, 1], offset: ?>>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.copy -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x573a529df810) {
  "linalg.yield"(%22) : (f32) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'linalg.yield -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x573a52a4b7f0) {
  %22 = "arith.addf"(%arg8, %21) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.addf -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a529e9520) {

  * Pattern (anonymous namespace)::TileLinalgOpPattern : 'linalg.matmul -> ()' {
Trying to match "(anonymous namespace)::TileLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: ""
"(anonymous namespace)::TileLinalgOpPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'linalg.matmul -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x573a52a4b370) {
  %21 = "arith.mulf"(%arg6, %arg7) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.mulf -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e830) {
  "memref.copy"(%11, %20) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.copy -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e790) {
  "memref.copy"(%10, %17) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.copy -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e6f0) {
  "memref.copy"(%9, %14) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.copy -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a529d08e0) {
  %20 = "memref.subview"(%19, %7, %8) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a4c9b0) {
  %18 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.view'(0x573a529d0ab0) {
  %19 = "memref.view"(%18, %0, %2, %2) : (memref<4096xi8>, index, index, index) -> memref<?x?xf32>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.view -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a529df880) {
  %17 = "memref.subview"(%16, %5, %6) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a4fba0) {
  %15 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.view'(0x573a529dfa50) {
  %16 = "memref.view"(%15, %0, %2, %2) : (memref<4096xi8>, index, index, index) -> memref<?x?xf32>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.view -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a529d8d70) {
  %14 = "memref.subview"(%13, %3, %4) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a4fd40) {
  %12 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.view'(0x573a52a3c860) {
  %13 = "memref.view"(%12, %0, %2, %2) : (memref<4096xi8>, index, index, index) -> memref<?x?xf32>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.view -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a9c0) {
  %11 = "memref.subview"(%arg2, %arg3, %arg4, %7, %8) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a890) {
  %10 = "memref.subview"(%arg1, %arg5, %arg4, %5, %6) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4c2c0) {
  %9 = "memref.subview"(%arg0, %arg3, %arg5, %3, %4) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49ad0) {
  %8 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49a40) {
  %7 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a499b0) {
  %6 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49920) {
  %5 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49790) {
  %4 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.parallel'(0x573a52a4c450) {

  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'scf.parallel -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x573a529ebb80) {

  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'scf.for -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a46cf0) {
  %3 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44e50) {
  %2 = "arith.constant"() <{value = 32 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44de0) {
  %1 = "arith.constant"() <{value = 2 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44d70) {
  %0 = "arith.constant"() <{value = 0 : index}> : () -> index


  * Pattern (anonymous namespace)::PromoteLinalgOpPattern : 'arith.constant -> ()' {
Trying to match "(anonymous namespace)::PromoteLinalgOpPattern"
    ** Match Failure :  does not have any filter from list: "L1"
"(anonymous namespace)::PromoteLinalgOpPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'func.return'(0x573a529df9e0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.reduce'(0x573a529d0870) {
  "scf.reduce"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x573a529d0a40) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a4f0b0) {
  "memref.dealloc"(%18) : (memref<4096xi8>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a45810) {
  "memref.dealloc"(%15) : (memref<4096xi8>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a37c40) {
  "memref.dealloc"(%12) : (memref<4096xi8>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e8d0) {
  "memref.copy"(%20, %11) : (memref<?x?xf32, strided<[?, 1]>>, memref<?x?xf32, strided<[2, 1], offset: ?>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x573a529df810) {
  "linalg.yield"(%22) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x573a52a4b7f0) {
  %22 = "arith.addf"(%arg8, %21) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a529e9520) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x573a52a4b370) {
  %21 = "arith.mulf"(%arg6, %arg7) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e830) {
  "memref.copy"(%11, %20) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e790) {
  "memref.copy"(%10, %17) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e6f0) {
  "memref.copy"(%9, %14) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a529d08e0) {
  %20 = "memref.subview"(%19, %7, %8) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
    ** Insert  : 'memref.alloc'(0x573a52a51d30)
    ** Replace : 'memref.subview'(0x573a529d08e0)
    ** Modified: 'memref.copy'(0x573a52a3e8d0)
    ** Modified: 'linalg.matmul'(0x573a529e9520)
    ** Modified: 'memref.copy'(0x573a52a3e830)
    ** Erase   : 'memref.subview'(0x573a529d08e0)
"(anonymous namespace)::RemoveSubViewOpsPattern" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
'memref.view' op operand #0 must be 1D memref of 8-bit signless integer values, but got 'memref<?x?xf32, 2>'
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<2x2xf32>, memref<2x2xf32>, memref<2x2xf32>) -> (), sym_name = "call_mmult"}> ({
^bb0(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>):
  %0 = "arith.constant"() <{value = 0 : index}> : () -> index
  %1 = "arith.constant"() <{value = 2 : index}> : () -> index
  %2 = "arith.constant"() <{value = 32 : index}> : () -> index
  "scf.parallel"(%0, %0, %1, %1, %2, %2) <{operandSegmentSizes = array<i32: 2, 2, 2, 0>}> ({
  ^bb0(%arg3: index, %arg4: index):
    "scf.for"(%0, %1, %2) ({
    ^bb0(%arg5: index):
      %3 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %4 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %5 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %6 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %7 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %8 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %9 = "memref.subview"(%arg0, %arg3, %arg5, %3, %4) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>
      %10 = "memref.subview"(%arg1, %arg5, %arg4, %5, %6) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>
      %11 = "memref.subview"(%arg2, %arg3, %arg4, %7, %8) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>
      %12 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>
      %13 = "memref.view"(%12, %0, %2, %2) : (memref<4096xi8>, index, index, index) -> memref<?x?xf32>
      %14 = "memref.subview"(%13, %3, %4) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>
      %15 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>
      %16 = "memref.view"(%15, %0, %2, %2) : (memref<4096xi8>, index, index, index) -> memref<?x?xf32>
      %17 = "memref.subview"(%16, %5, %6) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>
      %18 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>
      %19 = "memref.view"(%20, %0, %2, %2) : (memref<?x?xf32, 2>, index, index, index) -> memref<?x?xf32>
      %20 = "memref.alloc"(%7, %8) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>
      "memref.copy"(%9, %14) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()
      "memref.copy"(%10, %17) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()
      "memref.copy"(%11, %20) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, 2>) -> ()
      "linalg.matmul"(%14, %17, %20) <{indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], operandSegmentSizes = array<i32: 2, 1>}> ({
      ^bb0(%arg6: f32, %arg7: f32, %arg8: f32):
        %21 = "arith.mulf"(%arg6, %arg7) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
        %22 = "arith.addf"(%arg8, %21) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
        "linalg.yield"(%22) : (f32) -> ()
      }) {__internal_linalg_transform__ = "L1_promoted"} : (memref<?x?xf32, strided<[?, 1]>>, memref<?x?xf32, strided<[?, 1]>>, memref<?x?xf32, 2>) -> ()
      "memref.copy"(%20, %11) : (memref<?x?xf32, 2>, memref<?x?xf32, strided<[2, 1], offset: ?>>) -> ()
      "memref.dealloc"(%12) : (memref<4096xi8>) -> ()
      "memref.dealloc"(%15) : (memref<4096xi8>) -> ()
      "memref.dealloc"(%20) : (memref<?x?xf32, 2>) -> ()
      "scf.yield"() : () -> ()
    }) : (index, index, index) -> ()
    "scf.reduce"() : () -> ()
  }) : (index, index, index, index, index, index) -> ()
  "func.return"() : () -> ()
}) : () -> ()


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e830) {
  "memref.copy"(%11, %20) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a529e9520) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e8d0) {
  "memref.copy"(%20, %11) : (memref<?x?xf32, 2>, memref<?x?xf32, strided<[2, 1], offset: ?>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a51d30) {
  %20 = "memref.alloc"(%7, %8) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.view'(0x573a529d0ab0) {
  %19 = "memref.view"(%20, %0, %2, %2) : (memref<?x?xf32, 2>, index, index, index) -> memref<?x?xf32>

  ** Erase   : 'memref.view'(0x573a529d0ab0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a4c9b0) {
  %18 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>

  ** Erase   : 'memref.alloc'(0x573a52a4c9b0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a529df880) {
  %17 = "memref.subview"(%16, %5, %6) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
    ** Insert  : 'memref.alloc'(0x573a52a41f20)
    ** Replace : 'memref.subview'(0x573a529df880)
    ** Modified: 'linalg.matmul'(0x573a529e9520)
    ** Modified: 'memref.copy'(0x573a52a3e790)
    ** Erase   : 'memref.subview'(0x573a529df880)
"(anonymous namespace)::RemoveSubViewOpsPattern" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
'memref.view' op operand #0 must be 1D memref of 8-bit signless integer values, but got 'memref<?x?xf32, 2>'
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<2x2xf32>, memref<2x2xf32>, memref<2x2xf32>) -> (), sym_name = "call_mmult"}> ({
^bb0(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>):
  %0 = "arith.constant"() <{value = 0 : index}> : () -> index
  %1 = "arith.constant"() <{value = 2 : index}> : () -> index
  %2 = "arith.constant"() <{value = 32 : index}> : () -> index
  "scf.parallel"(%0, %0, %1, %1, %2, %2) <{operandSegmentSizes = array<i32: 2, 2, 2, 0>}> ({
  ^bb0(%arg3: index, %arg4: index):
    "scf.for"(%0, %1, %2) ({
    ^bb0(%arg5: index):
      %3 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %4 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %5 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %6 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %7 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %8 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %9 = "memref.subview"(%arg0, %arg3, %arg5, %3, %4) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>
      %10 = "memref.subview"(%arg1, %arg5, %arg4, %5, %6) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>
      %11 = "memref.subview"(%arg2, %arg3, %arg4, %7, %8) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>
      %12 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>
      %13 = "memref.view"(%12, %0, %2, %2) : (memref<4096xi8>, index, index, index) -> memref<?x?xf32>
      %14 = "memref.subview"(%13, %3, %4) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>
      %15 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>
      %16 = "memref.view"(%17, %0, %2, %2) : (memref<?x?xf32, 2>, index, index, index) -> memref<?x?xf32>
      %17 = "memref.alloc"(%5, %6) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>
      %18 = "memref.alloc"(%7, %8) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>
      "memref.copy"(%9, %14) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, strided<[?, 1]>>) -> ()
      "memref.copy"(%10, %17) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, 2>) -> ()
      "memref.copy"(%11, %18) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, 2>) -> ()
      "linalg.matmul"(%14, %17, %18) <{indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], operandSegmentSizes = array<i32: 2, 1>}> ({
      ^bb0(%arg6: f32, %arg7: f32, %arg8: f32):
        %19 = "arith.mulf"(%arg6, %arg7) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
        %20 = "arith.addf"(%arg8, %19) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
        "linalg.yield"(%20) : (f32) -> ()
      }) {__internal_linalg_transform__ = "L1_promoted"} : (memref<?x?xf32, strided<[?, 1]>>, memref<?x?xf32, 2>, memref<?x?xf32, 2>) -> ()
      "memref.copy"(%18, %11) : (memref<?x?xf32, 2>, memref<?x?xf32, strided<[2, 1], offset: ?>>) -> ()
      "memref.dealloc"(%12) : (memref<4096xi8>) -> ()
      "memref.dealloc"(%17) : (memref<?x?xf32, 2>) -> ()
      "memref.dealloc"(%18) : (memref<?x?xf32, 2>) -> ()
      "scf.yield"() : () -> ()
    }) : (index, index, index) -> ()
    "scf.reduce"() : () -> ()
  }) : (index, index, index, index, index, index) -> ()
  "func.return"() : () -> ()
}) : () -> ()


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e790) {
  "memref.copy"(%10, %17) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a529e9520) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a41f20) {
  %17 = "memref.alloc"(%5, %6) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.view'(0x573a529dfa50) {
  %16 = "memref.view"(%17, %0, %2, %2) : (memref<?x?xf32, 2>, index, index, index) -> memref<?x?xf32>

  ** Erase   : 'memref.view'(0x573a529dfa50)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a4fba0) {
  %15 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>

  ** Erase   : 'memref.alloc'(0x573a52a4fba0)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a529d8d70) {
  %14 = "memref.subview"(%13, %3, %4) <{operandSegmentSizes = array<i32: 1, 0, 2, 0>, static_offsets = array<i64: 0, 0>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<?x?xf32>, index, index) -> memref<?x?xf32, strided<[?, 1]>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
    ** Insert  : 'memref.alloc'(0x573a52a53800)
    ** Replace : 'memref.subview'(0x573a529d8d70)
    ** Modified: 'linalg.matmul'(0x573a529e9520)
    ** Modified: 'memref.copy'(0x573a52a3e6f0)
    ** Erase   : 'memref.subview'(0x573a529d8d70)
"(anonymous namespace)::RemoveSubViewOpsPattern" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
'memref.view' op operand #0 must be 1D memref of 8-bit signless integer values, but got 'memref<?x?xf32, 2>'
mlir-asm-printer: 'func.func' failed to verify and will be printed in generic form
"func.func"() <{function_type = (memref<2x2xf32>, memref<2x2xf32>, memref<2x2xf32>) -> (), sym_name = "call_mmult"}> ({
^bb0(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>):
  %0 = "arith.constant"() <{value = 0 : index}> : () -> index
  %1 = "arith.constant"() <{value = 2 : index}> : () -> index
  %2 = "arith.constant"() <{value = 32 : index}> : () -> index
  "scf.parallel"(%0, %0, %1, %1, %2, %2) <{operandSegmentSizes = array<i32: 2, 2, 2, 0>}> ({
  ^bb0(%arg3: index, %arg4: index):
    "scf.for"(%0, %1, %2) ({
    ^bb0(%arg5: index):
      %3 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %4 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %5 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %6 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %7 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %8 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index
      %9 = "memref.subview"(%arg0, %arg3, %arg5, %3, %4) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>
      %10 = "memref.subview"(%arg1, %arg5, %arg4, %5, %6) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>
      %11 = "memref.subview"(%arg2, %arg3, %arg4, %7, %8) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>
      %12 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>
      %13 = "memref.view"(%14, %0, %2, %2) : (memref<?x?xf32, 2>, index, index, index) -> memref<?x?xf32>
      %14 = "memref.alloc"(%3, %4) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>
      %15 = "memref.alloc"(%5, %6) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>
      %16 = "memref.alloc"(%7, %8) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>
      "memref.copy"(%9, %14) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, 2>) -> ()
      "memref.copy"(%10, %15) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, 2>) -> ()
      "memref.copy"(%11, %16) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, 2>) -> ()
      "linalg.matmul"(%14, %15, %16) <{indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], operandSegmentSizes = array<i32: 2, 1>}> ({
      ^bb0(%arg6: f32, %arg7: f32, %arg8: f32):
        %17 = "arith.mulf"(%arg6, %arg7) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
        %18 = "arith.addf"(%arg8, %17) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
        "linalg.yield"(%18) : (f32) -> ()
      }) {__internal_linalg_transform__ = "L1_promoted"} : (memref<?x?xf32, 2>, memref<?x?xf32, 2>, memref<?x?xf32, 2>) -> ()
      "memref.copy"(%16, %11) : (memref<?x?xf32, 2>, memref<?x?xf32, strided<[2, 1], offset: ?>>) -> ()
      "memref.dealloc"(%14) : (memref<?x?xf32, 2>) -> ()
      "memref.dealloc"(%15) : (memref<?x?xf32, 2>) -> ()
      "memref.dealloc"(%16) : (memref<?x?xf32, 2>) -> ()
      "scf.yield"() : () -> ()
    }) : (index, index, index) -> ()
    "scf.reduce"() : () -> ()
  }) : (index, index, index, index, index, index) -> ()
  "func.return"() : () -> ()
}) : () -> ()


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e6f0) {
  "memref.copy"(%9, %14) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<?x?xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a529e9520) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a53800) {
  %14 = "memref.alloc"(%3, %4) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.view'(0x573a52a3c860) {
  %13 = "memref.view"(%14, %0, %2, %2) : (memref<?x?xf32, 2>, index, index, index) -> memref<?x?xf32>

  ** Erase   : 'memref.view'(0x573a52a3c860)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a4fd40) {
  %12 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<4096xi8>

  ** Erase   : 'memref.alloc'(0x573a52a4fd40)
} -> success : operation is trivially dead
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a9c0) {
  %11 = "memref.subview"(%arg2, %arg3, %arg4, %7, %8) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a890) {
  %10 = "memref.subview"(%arg1, %arg5, %arg4, %5, %6) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4c2c0) {
  %9 = "memref.subview"(%arg0, %arg3, %arg5, %3, %4) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49ad0) {
  %8 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp> : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>"
getSliceBounds for first 1 variables
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a456b0> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
(Value	None	None	None	None	Value	Value	const)
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a456b0> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a456b0> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
 -1   0  -1  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
  1   0   0  >= 0
  1   0  -1  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]1 constraints
  1 -1 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]1 constraints
  1 -1 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
  1   1  -3  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

lb map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> ()
ub map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> (-d0 + 3)
FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]4 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]5 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

    ** Insert  : 'affine.apply'(0x573a52a51f50)
    ** Replace : 'affine.min'(0x573a52a49ad0)
    ** Modified: 'memref.alloc'(0x573a52a51d30)
    ** Modified: 'memref.subview'(0x573a52a4a9c0)
    ** Erase   : 'affine.min'(0x573a52a49ad0)
"(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
func.func @call_mmult(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>) {
  %c0 = arith.constant 0 : index
  %c2 = arith.constant 2 : index
  %c32 = arith.constant 32 : index
  scf.parallel (%arg3, %arg4) = (%c0, %c0) to (%c2, %c2) step (%c32, %c32) {
    scf.for %arg5 = %c0 to %c2 step %c32 {
      %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4)
      %4 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %5 = affine.apply affine_map<() -> (2)>()
      %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_0 = memref.subview %arg1[%arg5, %arg4] [%2, %3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_1 = memref.subview %arg2[%arg3, %arg4] [%4, %5] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %alloc = memref.alloc(%0, %1) : memref<?x?xf32, 2>
      %alloc_2 = memref.alloc(%2, %3) : memref<?x?xf32, 2>
      %alloc_3 = memref.alloc(%4, %5) : memref<?x?xf32, 2>
      memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_0, %alloc_2 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_1, %alloc_3 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_2 : memref<?x?xf32, 2>, memref<?x?xf32, 2>) outs(%alloc_3 : memref<?x?xf32, 2>)
      memref.copy %alloc_3, %subview_1 : memref<?x?xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      memref.dealloc %alloc : memref<?x?xf32, 2>
      memref.dealloc %alloc_2 : memref<?x?xf32, 2>
      memref.dealloc %alloc_3 : memref<?x?xf32, 2>
    }
    scf.reduce 
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a9c0) {
  %11 = "memref.subview"(%arg2, %arg3, %arg4, %7, %8) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a51d30) {
  %14 = "memref.alloc"(%7, %8) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x573a52a51f50) {
  %8 = "affine.apply"() <{map = affine_map<() -> (2)>}> : () -> index

} -> success : operation was folded
//===-------------------------------------------===//
** Insert  : 'arith.constant'(0x573a52a3e5b0)
** Replace : 'affine.apply'(0x573a52a51f50)
** Modified: 'memref.subview'(0x573a52a4a9c0)
** Modified: 'memref.alloc'(0x573a52a51d30)
** Erase   : 'affine.apply'(0x573a52a51f50)
// *** IR Dump After Successful Folding ***
scf.for %arg5 = %c0 to %c2 step %c32 {
  %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
  %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
  %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
  %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4)
  %4 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
  %c2_0 = arith.constant 2 : index
  %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_1 = memref.subview %arg1[%arg5, %arg4] [%2, %3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_2 = memref.subview %arg2[%arg3, %arg4] [%4, %c2_0] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %alloc = memref.alloc(%0, %1) : memref<?x?xf32, 2>
  %alloc_3 = memref.alloc(%2, %3) : memref<?x?xf32, 2>
  %alloc_4 = memref.alloc(%4, %c2_0) : memref<?x?xf32, 2>
  memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  memref.copy %subview_1, %alloc_3 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  memref.copy %subview_2, %alloc_4 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_3 : memref<?x?xf32, 2>, memref<?x?xf32, 2>) outs(%alloc_4 : memref<?x?xf32, 2>)
  memref.copy %alloc_4, %subview_2 : memref<?x?xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  memref.dealloc %alloc : memref<?x?xf32, 2>
  memref.dealloc %alloc_3 : memref<?x?xf32, 2>
  memref.dealloc %alloc_4 : memref<?x?xf32, 2>
}



//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a51d30) {
  %14 = "memref.alloc"(%7, %8) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a9c0) {
  %11 = "memref.subview"(%arg2, %arg3, %arg4, %7, %8) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a3e5b0) {
  %8 = "arith.constant"() <{value = 2 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49a40) {
  %7 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp> : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>"
getSliceBounds for first 1 variables
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45680> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
(Value	None	None	None	None	Value	Value	const)
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45680> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45680> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
 -1   0  -1  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
  1   0   0  >= 0
  1   0  -1  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]1 constraints
  1 -1 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]1 constraints
  1 -1 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
  1   1  -3  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

lb map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> ()
ub map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> (-d0 + 3)
FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]4 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]5 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

    ** Insert  : 'affine.apply'(0x573a52a51f50)
    ** Replace : 'affine.min'(0x573a52a49a40)
    ** Modified: 'memref.alloc'(0x573a52a51d30)
    ** Modified: 'memref.subview'(0x573a52a4a9c0)
    ** Erase   : 'affine.min'(0x573a52a49a40)
"(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
func.func @call_mmult(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>) {
  %c0 = arith.constant 0 : index
  %c2 = arith.constant 2 : index
  %c32 = arith.constant 32 : index
  scf.parallel (%arg3, %arg4) = (%c0, %c0) to (%c2, %c2) step (%c32, %c32) {
    scf.for %arg5 = %c0 to %c2 step %c32 {
      %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4)
      %4 = affine.apply affine_map<() -> (2)>()
      %c2_0 = arith.constant 2 : index
      %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_1 = memref.subview %arg1[%arg5, %arg4] [%2, %3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_2 = memref.subview %arg2[%arg3, %arg4] [%4, %c2_0] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %alloc = memref.alloc(%0, %1) : memref<?x?xf32, 2>
      %alloc_3 = memref.alloc(%2, %3) : memref<?x?xf32, 2>
      %alloc_4 = memref.alloc(%4, %c2_0) : memref<?x?xf32, 2>
      memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_1, %alloc_3 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_2, %alloc_4 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_3 : memref<?x?xf32, 2>, memref<?x?xf32, 2>) outs(%alloc_4 : memref<?x?xf32, 2>)
      memref.copy %alloc_4, %subview_2 : memref<?x?xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      memref.dealloc %alloc : memref<?x?xf32, 2>
      memref.dealloc %alloc_3 : memref<?x?xf32, 2>
      memref.dealloc %alloc_4 : memref<?x?xf32, 2>
    }
    scf.reduce 
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a9c0) {
  %11 = "memref.subview"(%arg2, %arg3, %arg4, %7, %8) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a51d30) {
  %14 = "memref.alloc"(%7, %8) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x573a52a51f50) {
  %7 = "affine.apply"() <{map = affine_map<() -> (2)>}> : () -> index

} -> success : operation was folded
//===-------------------------------------------===//
** Insert  : 'arith.constant'(0x573a52a3e620)
** Replace : 'affine.apply'(0x573a52a51f50)
** Modified: 'memref.subview'(0x573a52a4a9c0)
** Modified: 'memref.alloc'(0x573a52a51d30)
** Erase   : 'affine.apply'(0x573a52a51f50)
// *** IR Dump After Successful Folding ***
scf.for %arg5 = %c0 to %c2 step %c32 {
  %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
  %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
  %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
  %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4)
  %c2_0 = arith.constant 2 : index
  %c2_1 = arith.constant 2 : index
  %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_2 = memref.subview %arg1[%arg5, %arg4] [%2, %3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_3 = memref.subview %arg2[%arg3, %arg4] [%c2_0, %c2_1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %alloc = memref.alloc(%0, %1) : memref<?x?xf32, 2>
  %alloc_4 = memref.alloc(%2, %3) : memref<?x?xf32, 2>
  %alloc_5 = memref.alloc(%c2_0, %c2_1) : memref<?x?xf32, 2>
  memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  memref.copy %subview_2, %alloc_4 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  memref.copy %subview_3, %alloc_5 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_4 : memref<?x?xf32, 2>, memref<?x?xf32, 2>) outs(%alloc_5 : memref<?x?xf32, 2>)
  memref.copy %alloc_5, %subview_3 : memref<?x?xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  memref.dealloc %alloc : memref<?x?xf32, 2>
  memref.dealloc %alloc_4 : memref<?x?xf32, 2>
  memref.dealloc %alloc_5 : memref<?x?xf32, 2>
}



//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a51d30) {
  %14 = "memref.alloc"(%7, %8) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
    ** Insert  : 'memref.alloc'(0x573a52a53c40)
    ** Replace : 'memref.alloc'(0x573a52a51d30)
    ** Modified: 'memref.dealloc'(0x573a52a4f0b0)
    ** Modified: 'memref.copy'(0x573a52a3e830)
    ** Modified: 'linalg.matmul'(0x573a529e9520)
    ** Modified: 'memref.copy'(0x573a52a3e8d0)
    ** Erase   : 'memref.alloc'(0x573a52a51d30)
"(anonymous namespace)::MemrefsPattern" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
func.func @call_mmult(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>) {
  %c0 = arith.constant 0 : index
  %c2 = arith.constant 2 : index
  %c32 = arith.constant 32 : index
  scf.parallel (%arg3, %arg4) = (%c0, %c0) to (%c2, %c2) step (%c32, %c32) {
    scf.for %arg5 = %c0 to %c2 step %c32 {
      %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %3 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg4)
      %c2_0 = arith.constant 2 : index
      %c2_1 = arith.constant 2 : index
      %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_2 = memref.subview %arg1[%arg5, %arg4] [%2, %3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_3 = memref.subview %arg2[%arg3, %arg4] [%c2_0, %c2_1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %alloc = memref.alloc(%0, %1) : memref<?x?xf32, 2>
      %alloc_4 = memref.alloc(%2, %3) : memref<?x?xf32, 2>
      %alloc_5 = memref.alloc() : memref<2x2xf32, 2>
      memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_2, %alloc_4 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_3, %alloc_5 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_4 : memref<?x?xf32, 2>, memref<?x?xf32, 2>) outs(%alloc_5 : memref<2x2xf32, 2>)
      memref.copy %alloc_5, %subview_3 : memref<2x2xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      memref.dealloc %alloc : memref<?x?xf32, 2>
      memref.dealloc %alloc_4 : memref<?x?xf32, 2>
      memref.dealloc %alloc_5 : memref<2x2xf32, 2>
    }
    scf.reduce 
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a3e5b0) {
  %8 = "arith.constant"() <{value = 2 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e8d0) {
  "memref.copy"(%14, %11) : (memref<2x2xf32, 2>, memref<?x?xf32, strided<[2, 1], offset: ?>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a529e9520) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e830) {
  "memref.copy"(%11, %14) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a4f0b0) {
  "memref.dealloc"(%14) : (memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a53c40) {
  %14 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<2x2xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a9c0) {
  %11 = "memref.subview"(%arg2, %arg3, %arg4, %7, %8) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a3e620) {
  %7 = "arith.constant"() <{value = 2 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a499b0) {
  %6 = "affine.min"(%arg4) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp> : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>"
getSliceBounds for first 1 variables
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a456b0> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
(Value	None	None	None	None	Value	Value	const)
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a456b0> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a456b0> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
 -1   0  -1  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
  1   0   0  >= 0
  1   0  -1  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]1 constraints
  1 -1 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]1 constraints
  1 -1 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
  1   1  -3  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

lb map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> ()
ub map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> (-d0 + 3)
FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]4 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]5 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a456b0> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

    ** Insert  : 'affine.apply'(0x573a52a51f50)
    ** Replace : 'affine.min'(0x573a52a499b0)
    ** Modified: 'memref.alloc'(0x573a52a41f20)
    ** Modified: 'memref.subview'(0x573a52a4a890)
    ** Erase   : 'affine.min'(0x573a52a499b0)
"(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
func.func @call_mmult(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>) {
  %c0 = arith.constant 0 : index
  %c2 = arith.constant 2 : index
  %c32 = arith.constant 32 : index
  scf.parallel (%arg3, %arg4) = (%c0, %c0) to (%c2, %c2) step (%c32, %c32) {
    scf.for %arg5 = %c0 to %c2 step %c32 {
      %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %3 = affine.apply affine_map<() -> (2)>()
      %c2_0 = arith.constant 2 : index
      %c2_1 = arith.constant 2 : index
      %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_2 = memref.subview %arg1[%arg5, %arg4] [%2, %3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_3 = memref.subview %arg2[%arg3, %arg4] [%c2_0, %c2_1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %alloc = memref.alloc(%0, %1) : memref<?x?xf32, 2>
      %alloc_4 = memref.alloc(%2, %3) : memref<?x?xf32, 2>
      %alloc_5 = memref.alloc() : memref<2x2xf32, 2>
      memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_2, %alloc_4 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_3, %alloc_5 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_4 : memref<?x?xf32, 2>, memref<?x?xf32, 2>) outs(%alloc_5 : memref<2x2xf32, 2>)
      memref.copy %alloc_5, %subview_3 : memref<2x2xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      memref.dealloc %alloc : memref<?x?xf32, 2>
      memref.dealloc %alloc_4 : memref<?x?xf32, 2>
      memref.dealloc %alloc_5 : memref<2x2xf32, 2>
    }
    scf.reduce 
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a890) {
  %10 = "memref.subview"(%arg1, %arg5, %arg4, %5, %6) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a41f20) {
  %13 = "memref.alloc"(%5, %6) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x573a52a51f50) {
  %6 = "affine.apply"() <{map = affine_map<() -> (2)>}> : () -> index

} -> success : operation was folded
//===-------------------------------------------===//
** Insert  : 'arith.constant'(0x573a52a3e690)
** Replace : 'affine.apply'(0x573a52a51f50)
** Modified: 'memref.subview'(0x573a52a4a890)
** Modified: 'memref.alloc'(0x573a52a41f20)
** Erase   : 'affine.apply'(0x573a52a51f50)
// *** IR Dump After Successful Folding ***
scf.for %arg5 = %c0 to %c2 step %c32 {
  %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
  %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
  %2 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
  %c2_0 = arith.constant 2 : index
  %c2_1 = arith.constant 2 : index
  %c2_2 = arith.constant 2 : index
  %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_3 = memref.subview %arg1[%arg5, %arg4] [%2, %c2_0] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_4 = memref.subview %arg2[%arg3, %arg4] [%c2_1, %c2_2] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %alloc = memref.alloc(%0, %1) : memref<?x?xf32, 2>
  %alloc_5 = memref.alloc(%2, %c2_0) : memref<?x?xf32, 2>
  %alloc_6 = memref.alloc() : memref<2x2xf32, 2>
  memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  memref.copy %subview_3, %alloc_5 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  memref.copy %subview_4, %alloc_6 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
  linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_5 : memref<?x?xf32, 2>, memref<?x?xf32, 2>) outs(%alloc_6 : memref<2x2xf32, 2>)
  memref.copy %alloc_6, %subview_4 : memref<2x2xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  memref.dealloc %alloc : memref<?x?xf32, 2>
  memref.dealloc %alloc_5 : memref<?x?xf32, 2>
  memref.dealloc %alloc_6 : memref<2x2xf32, 2>
}



//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a41f20) {
  %13 = "memref.alloc"(%5, %6) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a890) {
  %10 = "memref.subview"(%arg1, %arg5, %arg4, %5, %6) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a3e690) {
  %6 = "arith.constant"() <{value = 2 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49920) {
  %5 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp> : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>"
getSliceBounds for first 1 variables
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45750> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
(Value	None	None	None	None	Value	Value	const)
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45750> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45750> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
 -1   0  -1  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
  1   0   0  >= 0
  1   0  -1  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]1 constraints
  1 -1 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]1 constraints
  1 -1 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
  1   1  -3  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

lb map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> ()
ub map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> (-d0 + 3)
FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]4 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]5 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

    ** Insert  : 'affine.apply'(0x573a52a51f50)
    ** Replace : 'affine.min'(0x573a52a49920)
    ** Modified: 'memref.alloc'(0x573a52a41f20)
    ** Modified: 'memref.subview'(0x573a52a4a890)
    ** Erase   : 'affine.min'(0x573a52a49920)
"(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
func.func @call_mmult(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>) {
  %c0 = arith.constant 0 : index
  %c2 = arith.constant 2 : index
  %c32 = arith.constant 32 : index
  scf.parallel (%arg3, %arg4) = (%c0, %c0) to (%c2, %c2) step (%c32, %c32) {
    scf.for %arg5 = %c0 to %c2 step %c32 {
      %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %2 = affine.apply affine_map<() -> (2)>()
      %c2_0 = arith.constant 2 : index
      %c2_1 = arith.constant 2 : index
      %c2_2 = arith.constant 2 : index
      %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_3 = memref.subview %arg1[%arg5, %arg4] [%2, %c2_0] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_4 = memref.subview %arg2[%arg3, %arg4] [%c2_1, %c2_2] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %alloc = memref.alloc(%0, %1) : memref<?x?xf32, 2>
      %alloc_5 = memref.alloc(%2, %c2_0) : memref<?x?xf32, 2>
      %alloc_6 = memref.alloc() : memref<2x2xf32, 2>
      memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_3, %alloc_5 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_4, %alloc_6 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_5 : memref<?x?xf32, 2>, memref<?x?xf32, 2>) outs(%alloc_6 : memref<2x2xf32, 2>)
      memref.copy %alloc_6, %subview_4 : memref<2x2xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      memref.dealloc %alloc : memref<?x?xf32, 2>
      memref.dealloc %alloc_5 : memref<?x?xf32, 2>
      memref.dealloc %alloc_6 : memref<2x2xf32, 2>
    }
    scf.reduce 
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a890) {
  %10 = "memref.subview"(%arg1, %arg5, %arg4, %5, %6) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a41f20) {
  %13 = "memref.alloc"(%5, %6) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x573a52a51f50) {
  %5 = "affine.apply"() <{map = affine_map<() -> (2)>}> : () -> index

} -> success : operation was folded
//===-------------------------------------------===//
** Insert  : 'arith.constant'(0x573a52a417e0)
** Replace : 'affine.apply'(0x573a52a51f50)
** Modified: 'memref.subview'(0x573a52a4a890)
** Modified: 'memref.alloc'(0x573a52a41f20)
** Erase   : 'affine.apply'(0x573a52a51f50)
// *** IR Dump After Successful Folding ***
scf.for %arg5 = %c0 to %c2 step %c32 {
  %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
  %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
  %c2_0 = arith.constant 2 : index
  %c2_1 = arith.constant 2 : index
  %c2_2 = arith.constant 2 : index
  %c2_3 = arith.constant 2 : index
  %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_4 = memref.subview %arg1[%arg5, %arg4] [%c2_0, %c2_1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_5 = memref.subview %arg2[%arg3, %arg4] [%c2_2, %c2_3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %alloc = memref.alloc(%0, %1) : memref<?x?xf32, 2>
  %alloc_6 = memref.alloc(%c2_0, %c2_1) : memref<?x?xf32, 2>
  %alloc_7 = memref.alloc() : memref<2x2xf32, 2>
  memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  memref.copy %subview_4, %alloc_6 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  memref.copy %subview_5, %alloc_7 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
  linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_6 : memref<?x?xf32, 2>, memref<?x?xf32, 2>) outs(%alloc_7 : memref<2x2xf32, 2>)
  memref.copy %alloc_7, %subview_5 : memref<2x2xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  memref.dealloc %alloc : memref<?x?xf32, 2>
  memref.dealloc %alloc_6 : memref<?x?xf32, 2>
  memref.dealloc %alloc_7 : memref<2x2xf32, 2>
}



//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a41f20) {
  %13 = "memref.alloc"(%5, %6) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
    ** Insert  : 'memref.alloc'(0x573a52a52070)
    ** Replace : 'memref.alloc'(0x573a52a41f20)
    ** Modified: 'memref.dealloc'(0x573a52a45810)
    ** Modified: 'memref.copy'(0x573a52a3e790)
    ** Modified: 'linalg.matmul'(0x573a529e9520)
    ** Erase   : 'memref.alloc'(0x573a52a41f20)
"(anonymous namespace)::MemrefsPattern" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
func.func @call_mmult(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>) {
  %c0 = arith.constant 0 : index
  %c2 = arith.constant 2 : index
  %c32 = arith.constant 32 : index
  scf.parallel (%arg3, %arg4) = (%c0, %c0) to (%c2, %c2) step (%c32, %c32) {
    scf.for %arg5 = %c0 to %c2 step %c32 {
      %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %1 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg5)
      %c2_0 = arith.constant 2 : index
      %c2_1 = arith.constant 2 : index
      %c2_2 = arith.constant 2 : index
      %c2_3 = arith.constant 2 : index
      %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_4 = memref.subview %arg1[%arg5, %arg4] [%c2_0, %c2_1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_5 = memref.subview %arg2[%arg3, %arg4] [%c2_2, %c2_3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %alloc = memref.alloc(%0, %1) : memref<?x?xf32, 2>
      %alloc_6 = memref.alloc() : memref<2x2xf32, 2>
      %alloc_7 = memref.alloc() : memref<2x2xf32, 2>
      memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_4, %alloc_6 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      memref.copy %subview_5, %alloc_7 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_6 : memref<?x?xf32, 2>, memref<2x2xf32, 2>) outs(%alloc_7 : memref<2x2xf32, 2>)
      memref.copy %alloc_7, %subview_5 : memref<2x2xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      memref.dealloc %alloc : memref<?x?xf32, 2>
      memref.dealloc %alloc_6 : memref<2x2xf32, 2>
      memref.dealloc %alloc_7 : memref<2x2xf32, 2>
    }
    scf.reduce 
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a3e690) {
  %6 = "arith.constant"() <{value = 2 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a529e9520) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e790) {
  "memref.copy"(%10, %13) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a45810) {
  "memref.dealloc"(%13) : (memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a52070) {
  %13 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<2x2xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a890) {
  %10 = "memref.subview"(%arg1, %arg5, %arg4, %5, %6) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a417e0) {
  %5 = "arith.constant"() <{value = 2 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a49790) {
  %4 = "affine.min"(%arg5) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp> : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>"
getSliceBounds for first 1 variables
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45750> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
(Value	None	None	None	None	Value	Value	const)
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45750> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45750> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
 -1   0  -1  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
  1   0   0  >= 0
  1   0  -1  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]1 constraints
  1 -1 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]1 constraints
  1 -1 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
  1   1  -3  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

lb map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> ()
ub map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> (-d0 + 3)
FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]4 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]5 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45750> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

    ** Insert  : 'affine.apply'(0x573a52a51f50)
    ** Replace : 'affine.min'(0x573a52a49790)
    ** Modified: 'memref.alloc'(0x573a52a53800)
    ** Modified: 'memref.subview'(0x573a52a4c2c0)
    ** Erase   : 'affine.min'(0x573a52a49790)
"(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
func.func @call_mmult(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>) {
  %c0 = arith.constant 0 : index
  %c2 = arith.constant 2 : index
  %c32 = arith.constant 32 : index
  scf.parallel (%arg3, %arg4) = (%c0, %c0) to (%c2, %c2) step (%c32, %c32) {
    scf.for %arg5 = %c0 to %c2 step %c32 {
      %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
      %1 = affine.apply affine_map<() -> (2)>()
      %c2_0 = arith.constant 2 : index
      %c2_1 = arith.constant 2 : index
      %c2_2 = arith.constant 2 : index
      %c2_3 = arith.constant 2 : index
      %subview = memref.subview %arg0[%arg3, %arg5] [%0, %1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_4 = memref.subview %arg1[%arg5, %arg4] [%c2_0, %c2_1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_5 = memref.subview %arg2[%arg3, %arg4] [%c2_2, %c2_3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %alloc = memref.alloc(%0, %1) : memref<?x?xf32, 2>
      %alloc_6 = memref.alloc() : memref<2x2xf32, 2>
      %alloc_7 = memref.alloc() : memref<2x2xf32, 2>
      memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_4, %alloc_6 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      memref.copy %subview_5, %alloc_7 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_6 : memref<?x?xf32, 2>, memref<2x2xf32, 2>) outs(%alloc_7 : memref<2x2xf32, 2>)
      memref.copy %alloc_7, %subview_5 : memref<2x2xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      memref.dealloc %alloc : memref<?x?xf32, 2>
      memref.dealloc %alloc_6 : memref<2x2xf32, 2>
      memref.dealloc %alloc_7 : memref<2x2xf32, 2>
    }
    scf.reduce 
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4c2c0) {
  %9 = "memref.subview"(%arg0, %arg3, %arg5, %3, %4) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a53800) {
  %12 = "memref.alloc"(%3, %4) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x573a52a51f50) {
  %4 = "affine.apply"() <{map = affine_map<() -> (2)>}> : () -> index

} -> success : operation was folded
//===-------------------------------------------===//
** Insert  : 'arith.constant'(0x573a52a56cd0)
** Replace : 'affine.apply'(0x573a52a51f50)
** Modified: 'memref.subview'(0x573a52a4c2c0)
** Modified: 'memref.alloc'(0x573a52a53800)
** Erase   : 'affine.apply'(0x573a52a51f50)
// *** IR Dump After Successful Folding ***
scf.for %arg5 = %c0 to %c2 step %c32 {
  %0 = affine.min affine_map<(d0) -> (-d0 + 2, 32)>(%arg3)
  %c2_0 = arith.constant 2 : index
  %c2_1 = arith.constant 2 : index
  %c2_2 = arith.constant 2 : index
  %c2_3 = arith.constant 2 : index
  %c2_4 = arith.constant 2 : index
  %subview = memref.subview %arg0[%arg3, %arg5] [%0, %c2_0] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_5 = memref.subview %arg1[%arg5, %arg4] [%c2_1, %c2_2] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_6 = memref.subview %arg2[%arg3, %arg4] [%c2_3, %c2_4] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %alloc = memref.alloc(%0, %c2_0) : memref<?x?xf32, 2>
  %alloc_7 = memref.alloc() : memref<2x2xf32, 2>
  %alloc_8 = memref.alloc() : memref<2x2xf32, 2>
  memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  memref.copy %subview_5, %alloc_7 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
  memref.copy %subview_6, %alloc_8 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
  linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_7 : memref<?x?xf32, 2>, memref<2x2xf32, 2>) outs(%alloc_8 : memref<2x2xf32, 2>)
  memref.copy %alloc_8, %subview_6 : memref<2x2xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  memref.dealloc %alloc : memref<?x?xf32, 2>
  memref.dealloc %alloc_7 : memref<2x2xf32, 2>
  memref.dealloc %alloc_8 : memref<2x2xf32, 2>
}



//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a53800) {
  %12 = "memref.alloc"(%3, %4) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4c2c0) {
  %9 = "memref.subview"(%arg0, %arg3, %arg5, %3, %4) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a56cd0) {
  %4 = "arith.constant"() <{value = 2 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.parallel'(0x573a52a4c450) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x573a529ebb80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.min'(0x573a52a46cf0) {
  %3 = "affine.min"(%arg3) <{map = affine_map<(d0) -> (-d0 + 2, 32)>}> : (index) -> index


  * Pattern (anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp> : 'affine.min -> ()' {
Trying to match "(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>"
getSliceBounds for first 1 variables
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45680> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
(Value	None	None	None	None	Value	Value	const)
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45680> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 5, Symbols: 2, Locals: 0
( ) -> ( Id<0x573a52a45680> None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]6 constraints
  0   0   0   0   0   1   0   0   = 0
  0   0   0   0   0   0   1  -2   = 0
  1   0   0   0   0  -1   0   0  >= 0
 -1   0   0   0   0   1   0   0  >= 0
 -1  -1   0   0   0   0   0   2  >= 0
  0  -1   0   0   0   0   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 4, Symbols: 2, Locals: 0
( ) -> ( None None None None ) : [ Id<0x573a52a44d60> Id<0x573a52a44dd0> ]4 constraints
  0   0   0   0   1   0   0   = 0
  0   0   0   0   0   1  -2   = 0
 -1   0   0   0  -1   0   2  >= 0
 -1   0   0   0   0   0   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
 -1   0  -1  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]1 constraints
 -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
  1   0   0  >= 0
  1   0  -1  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]1 constraints
  1 -1 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]1 constraints
  1 -1 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
  1   1  -3  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
 -1  -31 >= 0
  1   0  >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

lb map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> ()
ub map for pos = 1, expr: (d0, d1, d2, d3)[s0, s1] -> (-d0 + 3)
FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]4 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1  2 >= 0
  1 -2 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]0 constraints

FM input (eliminate pos 0):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( None None ) : [ ]5 constraints
  0  -1   2  >= 0
  0   1  -2  >= 0
 -1   1   0  >= 0
 -1   0   32 >= 0
  0   1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM input (eliminate pos 0):
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( None ) : [ ]2 constraints
 -1   2  >= 0
  1  -33 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 0, Symbols: 0, Locals: 0
( ) -> ( ) : [ ]1 constraints
 -1 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

FM input (eliminate pos 1):
Domain: 0, Range: 2, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> None ) : [ ]4 constraints
  1   0   0  >= 0
 -1   0   0  >= 0
 -1  -1   2  >= 0
  0  -1   32 >= 0

FM isResultIntegerExact: 1
FM output:
Domain: 0, Range: 1, Symbols: 0, Locals: 0
( ) -> ( Id<0x573a52a45680> ) : [ ]2 constraints
  1  0 >= 0
 -1  0 >= 0

    ** Insert  : 'affine.apply'(0x573a52a51f50)
    ** Replace : 'affine.min'(0x573a52a46cf0)
    ** Modified: 'memref.alloc'(0x573a52a53800)
    ** Modified: 'memref.subview'(0x573a52a4c2c0)
    ** Erase   : 'affine.min'(0x573a52a46cf0)
"(anonymous namespace)::AffineOpSCFCanonicalizationPattern<mlir::affine::AffineMinOp>" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
func.func @call_mmult(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>) {
  %c0 = arith.constant 0 : index
  %c2 = arith.constant 2 : index
  %c32 = arith.constant 32 : index
  scf.parallel (%arg3, %arg4) = (%c0, %c0) to (%c2, %c2) step (%c32, %c32) {
    scf.for %arg5 = %c0 to %c2 step %c32 {
      %0 = affine.apply affine_map<() -> (2)>()
      %c2_0 = arith.constant 2 : index
      %c2_1 = arith.constant 2 : index
      %c2_2 = arith.constant 2 : index
      %c2_3 = arith.constant 2 : index
      %c2_4 = arith.constant 2 : index
      %subview = memref.subview %arg0[%arg3, %arg5] [%0, %c2_0] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_5 = memref.subview %arg1[%arg5, %arg4] [%c2_1, %c2_2] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_6 = memref.subview %arg2[%arg3, %arg4] [%c2_3, %c2_4] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %alloc = memref.alloc(%0, %c2_0) : memref<?x?xf32, 2>
      %alloc_7 = memref.alloc() : memref<2x2xf32, 2>
      %alloc_8 = memref.alloc() : memref<2x2xf32, 2>
      memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
      memref.copy %subview_5, %alloc_7 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      memref.copy %subview_6, %alloc_8 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_7 : memref<?x?xf32, 2>, memref<2x2xf32, 2>) outs(%alloc_8 : memref<2x2xf32, 2>)
      memref.copy %alloc_8, %subview_6 : memref<2x2xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      memref.dealloc %alloc : memref<?x?xf32, 2>
      memref.dealloc %alloc_7 : memref<2x2xf32, 2>
      memref.dealloc %alloc_8 : memref<2x2xf32, 2>
    }
    scf.reduce 
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4c2c0) {
  %9 = "memref.subview"(%arg0, %arg3, %arg5, %3, %4) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a53800) {
  %12 = "memref.alloc"(%3, %4) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.parallel'(0x573a52a4c450) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x573a529ebb80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'affine.apply'(0x573a52a51f50) {
  %3 = "affine.apply"() <{map = affine_map<() -> (2)>}> : () -> index

} -> success : operation was folded
//===-------------------------------------------===//
** Insert  : 'arith.constant'(0x573a52a3f380)
** Replace : 'affine.apply'(0x573a52a51f50)
** Modified: 'memref.subview'(0x573a52a4c2c0)
** Modified: 'memref.alloc'(0x573a52a53800)
** Erase   : 'affine.apply'(0x573a52a51f50)
// *** IR Dump After Successful Folding ***
scf.for %arg5 = %c0 to %c2 step %c32 {
  %c2_0 = arith.constant 2 : index
  %c2_1 = arith.constant 2 : index
  %c2_2 = arith.constant 2 : index
  %c2_3 = arith.constant 2 : index
  %c2_4 = arith.constant 2 : index
  %c2_5 = arith.constant 2 : index
  %subview = memref.subview %arg0[%arg3, %arg5] [%c2_0, %c2_1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_6 = memref.subview %arg1[%arg5, %arg4] [%c2_2, %c2_3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %subview_7 = memref.subview %arg2[%arg3, %arg4] [%c2_4, %c2_5] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  %alloc = memref.alloc(%c2_0, %c2_1) : memref<?x?xf32, 2>
  %alloc_8 = memref.alloc() : memref<2x2xf32, 2>
  %alloc_9 = memref.alloc() : memref<2x2xf32, 2>
  memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<?x?xf32, 2>
  memref.copy %subview_6, %alloc_8 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
  memref.copy %subview_7, %alloc_9 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
  linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_8 : memref<?x?xf32, 2>, memref<2x2xf32, 2>) outs(%alloc_9 : memref<2x2xf32, 2>)
  memref.copy %alloc_9, %subview_7 : memref<2x2xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
  memref.dealloc %alloc : memref<?x?xf32, 2>
  memref.dealloc %alloc_8 : memref<2x2xf32, 2>
  memref.dealloc %alloc_9 : memref<2x2xf32, 2>
}



//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a53800) {
  %12 = "memref.alloc"(%3, %4) <{operandSegmentSizes = array<i32: 2, 0>}> : (index, index) -> memref<?x?xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
    ** Insert  : 'memref.alloc'(0x573a52a4fba0)
    ** Replace : 'memref.alloc'(0x573a52a53800)
    ** Modified: 'memref.dealloc'(0x573a52a37c40)
    ** Modified: 'memref.copy'(0x573a52a3e6f0)
    ** Modified: 'linalg.matmul'(0x573a529e9520)
    ** Erase   : 'memref.alloc'(0x573a52a53800)
"(anonymous namespace)::MemrefsPattern" result 1
  } -> success : pattern applied successfully
// *** IR Dump After Pattern Application ***
func.func @call_mmult(%arg0: memref<2x2xf32>, %arg1: memref<2x2xf32>, %arg2: memref<2x2xf32>) {
  %c0 = arith.constant 0 : index
  %c2 = arith.constant 2 : index
  %c32 = arith.constant 32 : index
  scf.parallel (%arg3, %arg4) = (%c0, %c0) to (%c2, %c2) step (%c32, %c32) {
    scf.for %arg5 = %c0 to %c2 step %c32 {
      %c2_0 = arith.constant 2 : index
      %c2_1 = arith.constant 2 : index
      %c2_2 = arith.constant 2 : index
      %c2_3 = arith.constant 2 : index
      %c2_4 = arith.constant 2 : index
      %c2_5 = arith.constant 2 : index
      %subview = memref.subview %arg0[%arg3, %arg5] [%c2_0, %c2_1] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_6 = memref.subview %arg1[%arg5, %arg4] [%c2_2, %c2_3] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %subview_7 = memref.subview %arg2[%arg3, %arg4] [%c2_4, %c2_5] [1, 1] : memref<2x2xf32> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      %alloc = memref.alloc() : memref<2x2xf32, 2>
      %alloc_8 = memref.alloc() : memref<2x2xf32, 2>
      %alloc_9 = memref.alloc() : memref<2x2xf32, 2>
      memref.copy %subview, %alloc : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      memref.copy %subview_6, %alloc_8 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      memref.copy %subview_7, %alloc_9 : memref<?x?xf32, strided<[2, 1], offset: ?>> to memref<2x2xf32, 2>
      linalg.matmul {__internal_linalg_transform__ = "L1_promoted"} ins(%alloc, %alloc_8 : memref<2x2xf32, 2>, memref<2x2xf32, 2>) outs(%alloc_9 : memref<2x2xf32, 2>)
      memref.copy %alloc_9, %subview_7 : memref<2x2xf32, 2> to memref<?x?xf32, strided<[2, 1], offset: ?>>
      memref.dealloc %alloc : memref<2x2xf32, 2>
      memref.dealloc %alloc_8 : memref<2x2xf32, 2>
      memref.dealloc %alloc_9 : memref<2x2xf32, 2>
    }
    scf.reduce 
  }
  return
}


} -> success : pattern matched
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a56cd0) {
  %4 = "arith.constant"() <{value = 2 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a529e9520) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e6f0) {
  "memref.copy"(%9, %12) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a37c40) {
  "memref.dealloc"(%12) : (memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a4fba0) {
  %12 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<2x2xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4c2c0) {
  %9 = "memref.subview"(%arg0, %arg3, %arg5, %3, %4) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.parallel'(0x573a52a4c450) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x573a529ebb80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a3f380) {
  %3 = "arith.constant"() <{value = 2 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44e50) {
  %2 = "arith.constant"() <{value = 32 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44de0) {
  %1 = "arith.constant"() <{value = 2 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44d70) {
  %0 = "arith.constant"() <{value = 0 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
** Replace : 'arith.constant'(0x573a52a3f380)
** Modified: 'memref.subview'(0x573a52a4c2c0)
** Erase   : 'arith.constant'(0x573a52a3f380)
** Replace : 'arith.constant'(0x573a52a56cd0)
** Modified: 'memref.subview'(0x573a52a4c2c0)
** Erase   : 'arith.constant'(0x573a52a56cd0)
** Replace : 'arith.constant'(0x573a52a417e0)
** Modified: 'memref.subview'(0x573a52a4a890)
** Erase   : 'arith.constant'(0x573a52a417e0)
** Replace : 'arith.constant'(0x573a52a3e690)
** Modified: 'memref.subview'(0x573a52a4a890)
** Erase   : 'arith.constant'(0x573a52a3e690)
** Replace : 'arith.constant'(0x573a52a3e620)
** Modified: 'memref.subview'(0x573a52a4a9c0)
** Erase   : 'arith.constant'(0x573a52a3e620)
** Replace : 'arith.constant'(0x573a52a3e5b0)
** Modified: 'memref.subview'(0x573a52a4a9c0)
** Erase   : 'arith.constant'(0x573a52a3e5b0)

//===-------------------------------------------===//
Processing operation : 'func.return'(0x573a529df9e0) {
  "func.return"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.reduce'(0x573a529d0870) {
  "scf.reduce"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.yield'(0x573a529d0a40) {
  "scf.yield"() : () -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a4f0b0) {
  "memref.dealloc"(%8) : (memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a45810) {
  "memref.dealloc"(%7) : (memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.dealloc'(0x573a52a37c40) {
  "memref.dealloc"(%6) : (memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e8d0) {
  "memref.copy"(%8, %5) : (memref<2x2xf32, 2>, memref<?x?xf32, strided<[2, 1], offset: ?>>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.yield'(0x573a529df810) {
  "linalg.yield"(%10) : (f32) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.addf'(0x573a52a4b7f0) {
  %10 = "arith.addf"(%arg8, %9) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'linalg.matmul'(0x573a529e9520) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.mulf'(0x573a52a4b370) {
  %9 = "arith.mulf"(%arg6, %arg7) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e830) {
  "memref.copy"(%5, %8) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e790) {
  "memref.copy"(%4, %7) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.copy'(0x573a52a3e6f0) {
  "memref.copy"(%3, %6) : (memref<?x?xf32, strided<[2, 1], offset: ?>>, memref<2x2xf32, 2>) -> ()

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a53c40) {
  %8 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<2x2xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a52070) {
  %7 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<2x2xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.alloc'(0x573a52a4fba0) {
  %6 = "memref.alloc"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<2x2xf32, 2>


  * Pattern (anonymous namespace)::MemrefsPattern : 'memref.alloc -> ()' {
Trying to match "(anonymous namespace)::MemrefsPattern"
"(anonymous namespace)::MemrefsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a9c0) {
  %5 = "memref.subview"(%arg2, %arg3, %arg4, %1, %1) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4a890) {
  %4 = "memref.subview"(%arg1, %arg5, %arg4, %1, %1) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.parallel'(0x573a52a4c450) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'scf.for'(0x573a529ebb80) {
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'memref.subview'(0x573a52a4c2c0) {
  %3 = "memref.subview"(%arg0, %arg3, %arg5, %1, %1) <{operandSegmentSizes = array<i32: 1, 2, 2, 0>, static_offsets = array<i64: -9223372036854775808, -9223372036854775808>, static_sizes = array<i64: -9223372036854775808, -9223372036854775808>, static_strides = array<i64: 1, 1>}> : (memref<2x2xf32>, index, index, index, index) -> memref<?x?xf32, strided<[2, 1], offset: ?>>


  * Pattern (anonymous namespace)::RemoveSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::RemoveSubViewOpsPattern"
"(anonymous namespace)::RemoveSubViewOpsPattern" result 0
  } -> failure : pattern failed to match

  * Pattern (anonymous namespace)::FoldSubViewOpsPattern : 'memref.subview -> ()' {
Trying to match "(anonymous namespace)::FoldSubViewOpsPattern"
"(anonymous namespace)::FoldSubViewOpsPattern" result 0
  } -> failure : pattern failed to match
} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44e50) {
  %2 = "arith.constant"() <{value = 32 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44de0) {
  %1 = "arith.constant"() <{value = 2 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//

//===-------------------------------------------===//
Processing operation : 'arith.constant'(0x573a52a44d70) {
  %0 = "arith.constant"() <{value = 0 : index}> : () -> index

} -> failure : pattern failed to match
//===-------------------------------------------===//
ImplicitTypeIDRegistry::lookupOrInsert(mlir::AttributeTrait::IsLocation<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::detail::PreservedAnalyses::AllAnalysesType)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::TypedAttr::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::ElementsAttr::Trait<Empty>)
ImplicitTypeIDRegistry::lookupOrInsert(mlir::MemRefLayoutAttrInterface::Trait<Empty>)
